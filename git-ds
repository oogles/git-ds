#!/usr/bin/env bash

# Defaults for global settings
output_path='.git/ds'
max_branch_diffs=10

# Update global settings with values from the config file, if any.
# NOTE: Do this before creating any other variables used by the program, so
# that a manually-modified config file can't be used to alter expected behaviour.
if [[ -f .git/ds.cfg ]]; then
    source .git/ds.cfg
fi

# Defaults for per-execution settings
label=''

# TODO: Validate max_branch_diffs is integer - here and when retrieving the -n option in --config

# Unconfigurable settings
TEMP_FILE='.git/.dstemp.patch'
CRON_COMMAND=''

# TODO: Keep a log?

function set_cron_command() {

    local git_ds_file=$( which git-ds )
    if [[ ! "$git_ds_file" ]]; then
        echo "git-ds must be available on the system PATH."
        exit 1
    fi

    CRON_COMMAND="cd $PWD && $git_ds_file --run"

}

function has_cron() {

    set_cron_command

    if [[ $( crontab -l | grep -F "$CRON_COMMAND" ) ]]; then
        return 0  # success (effectively true)
    else
        return 1  # failure (effectively false)
    fi

}

function show_help() {
    echo "Show help"
}

function config() {

    local options="$@"

    # Get provided config options, overriding defaults
    while [[ $# -gt 0 ]]; do
        case $1 in
        -o)
            output_path="$2"
            ;;
        -n)
            max_branch_diffs="$2"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
        esac

        shift  # move past option argument
        shift  # move past value argument
    done

    if [[ ! "$options" ]]; then
        if [[ ! -f .git/ds.cfg ]]; then
            echo "No config file found. Default settings:"
        else
            echo "Config file loaded. Settings:"
        fi

        echo "Output path: $output_path"
        echo "Max. number of diff files per branch: $max_branch_diffs"
    else
        printf "output_path='$output_path'\nmax_branch_diffs=$max_branch_diffs" > .git/ds.cfg
        echo "Config file saved."
    fi

}

function run() {

    if [[ -f "$TEMP_FILE" ]]; then
        echo "Diff already in progress."
        exit 1
    fi

    # Get optional label, if any
    local label=''
    while [[ $# -gt 0 ]]; do
        case $1 in
        -l)
            label="$2"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
            ;;
        esac

        shift  # move past option argument
        shift  # move past value argument
    done

    local branch=$(git symbolic-ref --short -q HEAD)
    local dir="$output_path/$branch"
    mkdir -p "$dir"

    local diff=$({ git --no-pager diff HEAD; for next in $( git ls-files --others --exclude-standard ) ; do git --no-pager diff --no-index /dev/null $next; done; })

    # Write the diff to a temporary file
    echo "$diff" > "$TEMP_FILE"

    local count=$(ls -1 "$dir" | wc -l)
    if [[ "$count" -gt 0 ]]; then
        # Get the most and least recent previous diff files
        unset -v newest
        unset -v oldest
        for file in "$dir"/*; do
            [[ "$file" -nt "$newest" ]] && newest="$file"
            [[ -z "$oldest" || "$file" -ot "$oldest" ]] && oldest="$file"
        done

        local diff_comp=$(diff "$TEMP_FILE" "$newest")
        if [[ ! "$diff_comp" ]]; then
            # Only keep the file if this diff actually differs from the
            # previous one
            rm "$TEMP_FILE"
        elif [[ "$count" -ge "$max_branch_diffs" ]]; then
            # Remove the oldest file if there are more than the configured max
            # number of rotating files for this branch
            rm "$oldest"
        fi
    fi

    if [[ -f "$TEMP_FILE" ]]; then
        # Move the temporary file to a permanent location
        local filename=$(date '+%Y%m%d-%H%M%S')
        if [[ "$label" ]]; then
            filename="$filename-$label"
        fi

        mv "$TEMP_FILE" "$dir/$filename.patch"
    fi

}

function watch() {

    set_cron_command

    # TODO: Allow configuring schedule
    # TODO: Note that calling --watch again, when the repo is already being
    #  watched, can serve to update the cronjob's schedule, if it has been
    #  modified via --config
    local schedule='*/5 * * * *'
    local job="$schedule $CRON_COMMAND"

    # Add the cronjob, with no duplication, updating its schedule if it has
    # been modified
    ( crontab -l | grep -v -F "$CRON_COMMAND" ; echo "$job" ) | crontab -

    echo "Started cronjob with schedule: $schedule"

}

function unwatch() {

    if ! has_cron; then
        echo "Repository is not currently being watched."
    else
        # Remove the cronjob, regardless of its schedule
        ( crontab -l | grep -v -F "$CRON_COMMAND" ) | crontab -
    fi

}

function clean() {
    echo "Clean diff files"
}

function status() {

    has_cron && local watching='Yes' || local watching='No (try "git ds --watch")'
    echo -e "\nRepository being watched: $watching\n"

    shopt -s nullglob  # handle empty directories nicely

    echo "Branches with saved diffs:"
    local tracked_branches=0
    for path in "$output_path"/*; do
        [[ -d "$path" ]] || continue  # skip if not a directory

        local branch=$( basename "$path" )
        local count=$( ls -1 "$path" | wc -l )

        local latest
        for file in "$path"/*; do
            [[ "$file" -nt "$latest" ]] && latest=$( date -r "$file" '+%Y-%m-%d %H:%M:%S' )
        done

        echo "$branch ($count files, latest: $latest)"

        tracked_branches=$((tracked_branches + 1))
    done

    if [[ "$tracked_branches" -eq 0 ]]; then
        echo "None"
    fi

    shopt -u nullglob

}

# Show statistics when no subcommand is given
subcommand="$1"

if [[ ! "$subcommand" ]]; then
    status
    exit 0
fi

shift  # move past subcommand option

# Execute the appropriate subcommand
case "$subcommand" in
-h|--help)
    show_help
    ;;
--config)
    config "$@"  # pass the remaining options through
    ;;
--run)
    run "$@"  # pass the remaining options through
    ;;
--watch)
    watch
    ;;
--unwatch)
    unwatch
    ;;
--clean)
    clean
    ;;
*)
    echo "Unexpected option: $subcommand. See git ds --help for usage examples."
    exit 1
    ;;
esac
