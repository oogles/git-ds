#!/usr/bin/env bash

# Defaults for global settings
output_path='.git/ds'
max_branch_diffs=10

# Update global settings with values from the config file, if any.
# NOTE: Do this before creating any other variables used by the program, so
# that a manually-modified config file can't be used to alter expected behaviour.
if [[ -f .git/ds.cfg ]]; then
    source .git/ds.cfg
fi

# Defaults for per-execution settings
label=''

# TODO: Validate max_branch_diffs is integer - here and when retrieving the -n option in --config

# Unconfigurable settings
TEMP_FILE='.git/.dstemp.patch'
BRANCH=$(git symbolic-ref --short -q HEAD)

# TODO
watching=0

# TODO: Keep a log

function show_help() {
    echo "Show help"
}

function config() {

    local options="$@"

    # Get provided config options, overriding defaults
    while [[ $# -gt 0 ]]; do
        case $1 in
        -o)
            output_path="$2"
            ;;
        -n)
            max_branch_diffs="$2"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
        esac

        shift  # move past option argument
        shift  # move past value argument
    done

    if [[ ! "$options" ]]; then
        if [[ ! -f .git/ds.cfg ]]; then
            echo "No config file found. Default settings:"
        else
            echo "Config file loaded. Settings:"
        fi

        echo "Output path: $output_path"
        echo "Max. number of diff files per branch: $max_branch_diffs"
    else
        printf "output_path='$output_path'\nmax_branch_diffs=$max_branch_diffs" > .git/ds.cfg
        echo "Config file saved."
    fi

}

function run() {

    local label="$1"

    local dir="$output_path/$BRANCH"
    mkdir -p "$dir"

    local diff=$({ git --no-pager diff HEAD; for next in $( git ls-files --others --exclude-standard ) ; do git --no-pager diff --no-index /dev/null $next; done; })

    echo "$diff" > "$TEMP_FILE"

    local count=$(ls -1 "$dir" | wc -l)
    if [[ "$count" -gt 0 ]]; then
        # Get the most and least recent previous diff files
        unset -v newest
        unset -v oldest
        for file in "$dir"/*; do
            [[ "$file" -nt "$newest" ]] && newest="$file"
            [[ -z "$oldest" || "$file" -ot "$oldest" ]] && oldest="$file"
        done

        # Only write a new file if this diff actually differs from the previous one
        local diff_comp=$(diff "$TEMP_FILE" "$newest")
        if [[ ! "$diff_comp" ]]; then
            return
        fi

        # Remove the oldest file if there are more than the configured max
        # number of rotating files
        if [[ "$count" -ge "$max_branch_diffs" ]]; then
            rm "$oldest"
        fi
    fi

    local filename=$(date '+%Y%m%d-%H%M%S')
    if [[ "$label" ]]; then
        filename="$filename-$label"
    fi

    cp "$TEMP_FILE" "$dir/$filename.patch"

}

function watch() {

    if [[ watching -eq 1 ]]; then
        git ds
        exit 0
    fi

    echo "Register hooks + cron"

    # register hooks
    # post-checkout:
        # branch checkout: can't leave a branch with uncommitted changes (they'll follow you), so write a blank diff for the previous branch
        # file checkout: update the diff to ensure it excludes the checked-out file
    # post-commit: update the diff to ensure it excludes the files just committed
        # does this run on git commit --amend?
    # stash?
        # no available hooks, will have to be a blind spot

    # TODO: handle existing hooks
    # TODO: register cron job
        # configurable interval

}

function unwatch() {

    if [[ watching -eq 0 ]]; then
        echo "Repository is not currently being watched."
        exit 0
    fi

    echo "Unregister hooks + cron"

}

function clean() {
    echo "Clean diff files"
}

function status() {
    echo "Show status + statistics"
}

# Execute the appropriate subcommand
case "$1" in
-h|--help)
    shift  # move past subcommand option
    show_help
    ;;
--config)
    shift  # move past subcommand option
    config "$@"  # pass the remaining options
    ;;
--run)
    shift  # move past subcommand option

    if [[ -f "$TEMP_FILE" ]]; then
        echo "Diff already in progress."
        exit 1
    fi

    # Get label, if any
    unset label
    while [[ $# -gt 0 ]]; do
        case $1 in
        -l)
            label="$2"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
            ;;
        esac

        shift  # move past option argument
        shift  # move past value argument
    done

    run "$label"

    # Always remove the temporary diff file, regardless of the outcome of run
    rm "$TEMP_FILE"
    ;;
--watch)
    shift  # move past subcommand option
    watch
    ;;
--unwatch)
    shift  # move past subcommand option
    unwatch
    ;;
--clean)
    shift  # move past subcommand option
    clean
    ;;
*)
    # no subcommand option, no shift
    status
    ;;
esac
