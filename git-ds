#!/usr/bin/env bash

# Ensure the current directory is a valid git repository
if [[ ! -d .git ]] || ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in the root directory of a valid git repository."
    exit 1
fi

# Defaults for global settings
output_path='.git/ds'
max_branch_diffs=10

# Update global settings with values from the config file, if any.
# NOTE: Do this before creating any other variables used by the program, so
# that a manually-modified config file can't be used to alter expected behaviour.
if [[ -f .git/ds.cfg ]]; then
    source .git/ds.cfg
fi

# Defaults for per-execution settings
label=''

# TODO: Validate max_branch_diffs is integer - here and when retrieving the -n option in --config
# TODO: Validate (or at least document) that output_path should NOT contain a trailing slash

# Unconfigurable settings
TEMP_FILE='.git/.dstemp.patch'
CURRENT_BRANCHES=()
CRON_COMMAND=''

# TODO: Keep a log?

#
# Util functions
#

function is_in() {

    # https://stackoverflow.com/a/8574392/405174
    local e match="$1"
    shift
    for e; do [[ "$e" == "$match" ]] && return 0; done
    return 1

}

function set_current_branches() {

    eval "$(git for-each-ref --shell --format='CURRENT_BRANCHES+=(%(refname))' refs/heads/)"

    # Trim refs/heads/ from the branch names
    for i in "${!CURRENT_BRANCHES[@]}"; do
        branch="${CURRENT_BRANCHES[$i]}"
        branch="${branch#refs/heads/}"
        CURRENT_BRANCHES[$i]="$branch"
    done

}

function branch_stats() {

    local path="$1"
    local branch=$( basename "$path" )
    local count=$( ls -1 "$path" | wc -l )

    local latest='n/a'
    for file in "$path"/*; do
        [[ "$file" -nt "$latest" ]] && latest=$( date -r "$file" '+%Y-%m-%d %H:%M:%S' )
    done

    if ! is_in "$branch" "${CURRENT_BRANCHES[@]}"; then
        local obsolete='[obsolete] '
    else
        local obsolete=''
    fi

    echo "$branch $obsolete($count files, latest: $latest)"

}

function set_cron_command() {

    local git_ds_file=$( which git-ds )
    if [[ ! "$git_ds_file" ]]; then
        echo "git-ds must be available on the system PATH."
        exit 1
    fi

    CRON_COMMAND="cd $PWD && $git_ds_file --run"

}

function has_cron() {

    set_cron_command

    if [[ $( crontab -l | grep -F "$CRON_COMMAND" ) ]]; then
        return 0  # success (effectively true)
    else
        return 1  # failure (effectively false)
    fi

}

#
# Subcommand functions
#

function show_help() {
    echo "Show help"
}

function config() {

    local options="$@"

    # Get provided config options, overriding defaults
    while [[ $# -gt 0 ]]; do
        case $1 in
        -o)
            output_path="$2"
            ;;
        -n)
            max_branch_diffs="$2"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
        esac

        shift  # move past option argument
        shift  # move past value argument
    done

    if [[ ! "$options" ]]; then
        if [[ ! -f .git/ds.cfg ]]; then
            echo "No config file found. Default settings:"
        else
            echo "Config file loaded. Settings:"
        fi

        echo "Output path: $output_path"
        echo "Max. number of diff files per branch: $max_branch_diffs"
    else
        printf "output_path='$output_path'\nmax_branch_diffs=$max_branch_diffs" > .git/ds.cfg
        echo "Config file saved."
    fi

}

function run() {

    if [[ -f "$TEMP_FILE" ]]; then
        echo "Diff already in progress."
        exit 1
    fi

    # Get optional label, if any
    local label=''
    while [[ $# -gt 0 ]]; do
        case $1 in
        -l)
            label="$2"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
            ;;
        esac

        shift  # move past option argument
        shift  # move past value argument
    done

    local branch=$(git symbolic-ref --short -q HEAD)
    local dir="$output_path/$branch"
    mkdir -p "$dir"

    local diff=$({ git --no-pager diff HEAD; for next in $( git ls-files --others --exclude-standard ) ; do git --no-pager diff --no-index /dev/null $next; done; })

    # Write the diff to a temporary file
    echo "$diff" > "$TEMP_FILE"

    local count=$(ls -1 "$dir" | wc -l)
    if [[ "$count" -gt 0 ]]; then
        # Get the most and least recent previous diff files
        unset -v newest
        unset -v oldest
        for file in "$dir"/*; do
            [[ "$file" -nt "$newest" ]] && newest="$file"
            [[ -z "$oldest" || "$file" -ot "$oldest" ]] && oldest="$file"
        done

        local diff_comp=$(diff "$TEMP_FILE" "$newest")
        if [[ ! "$diff_comp" ]]; then
            # Only keep the file if this diff actually differs from the
            # previous one
            rm "$TEMP_FILE"
        elif [[ "$count" -ge "$max_branch_diffs" ]]; then
            # Remove the oldest file if there are more than the configured max
            # number of rotating files for this branch
            rm "$oldest"
        fi
    fi

    if [[ -f "$TEMP_FILE" ]]; then
        # Move the temporary file to a permanent location
        local filename=$(date '+%Y%m%d-%H%M%S')
        if [[ "$label" ]]; then
            filename="$filename-$label"
        fi

        mv "$TEMP_FILE" "$dir/$filename.patch"
    fi

}

function watch() {

    set_cron_command

    # Get schedule
    if [[ ! "$1" ]]; then
        # No scheduling options provided
        local schedule='*/5 * * * *'
    else
        # Scheduling options provided - only the first is considered, if
        # multiple were provided
        case $1 in
        -s)
            local schedule="$2"
            ;;
        -m)
            local schedule="*/$2 * * * *"
            ;;
        *)
            echo "Unknown option: $1. See git ds --help for usage examples."
            exit 1
            ;;
        esac
    fi

    local job="$schedule $CRON_COMMAND"

    # Add the cronjob, with no duplication, updating its schedule if it has
    # been modified
    ( crontab -l | grep -v -F "$CRON_COMMAND" ; echo "$job" ) | crontab -

    if [[ "$?" -eq 0 ]]; then
        echo "Started cronjob with schedule: $schedule"
    fi

}

function unwatch() {

    if ! has_cron; then
        echo "Repository is not currently being watched."
    else
        # Remove the cronjob, regardless of its schedule
        ( crontab -l | grep -v -F "$CRON_COMMAND" ) | crontab -
    fi

}

function clean() {

    shopt -s nullglob  # handle empty directories nicely

    set_current_branches

    # Get all branches with saved diff data and filter them to those that are
    # now obsolete
    saved_branches=("$output_path"/*/)
    obsolete_paths=()

    for path in "${saved_branches[@]}"; do
        # Extract branch name from path
        branch=$( basename "$path" )

        # Store the branch if it is no longer current
        if ! is_in "$branch" "${CURRENT_BRANCHES[@]}"; then
            obsolete_paths+=("$path")
        fi
    done

    local count=${#obsolete_paths[@]}
    if [[ "$count" -gt 0 ]]; then
        echo "Saved diffs for $count obsolete branches found."
        echo 'The following will be removed:'
        for path in "${obsolete_paths[@]}"; do
            # Show info about each obsolete branch
            branch_stats "$path"
        done

        echo
        read -p "Continue? " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            for path in "${obsolete_paths[@]}"; do
                rm -rf "$path"
                echo "Obsolete files removed."
            done
        fi
    else
        echo 'No saved diffs for obsolete branches found.'
    fi

    shopt -u nullglob

}

function status() {

    has_cron && local watching='Yes' || local watching='No (try "git ds --watch")'
    echo -e "\nRepository being watched: $watching\n"

    shopt -s nullglob  # handle empty directories nicely
    set_current_branches  # for branch_stats

    echo 'Branches with saved diffs:'
    local tracked_branches=0
    for path in "$output_path"/*; do
        [[ -d "$path" ]] || continue  # skip if not a directory

        branch_stats "$path"

        tracked_branches=$((tracked_branches + 1))
    done

    if [[ "$tracked_branches" -eq 0 ]]; then
        echo 'None'
        echo -e '\nUse "git ds --run" to save diff files for uncommitted changes.'
    else
        echo -e '\nUse "git ds --clean" to remove obsolete files.'
    fi

    shopt -u nullglob

}

# Show statistics when no subcommand is given
subcommand="$1"

if [[ ! "$subcommand" ]]; then
    status
    exit 0
fi

shift  # move past subcommand option

# Execute the appropriate subcommand
case "$subcommand" in
-h|--help)
    show_help
    ;;
--config)
    config "$@"  # pass the remaining options through
    ;;
--run)
    run "$@"  # pass the remaining options through
    ;;
--watch)
    watch "$@"  # pass the remaining options through
    ;;
--unwatch)
    unwatch
    ;;
--clean)
    clean
    ;;
*)
    echo "Unexpected option: $subcommand. See git ds --help for usage examples."
    exit 1
    ;;
esac
